:toc: macro 

include::Title.adoc[lines=1..8]

[.text-center]
Отчет по лабораторной работе №9 +
на тему "Таймеры"

include::Title.adoc[lines=12..24]

== Оглавление

toc::[]

== Введение

Цель: Написать программу моргания всеми 4 светодиодами на плате с периодом в 0.5 секунды. По нажатию кнопки увеличивать период моргания на 0.1 секунды. Реализовать задержку на таймере 2

== Практическая часть

.main.cpp
[source, cpp]
----

#include "rccregisters.hpp" // for RCC
#include "gpioaregisters.hpp" // for GPIOA
#include "gpiocregisters.hpp" // for GPIOÑ

#include "stkregisters.hpp" // for SYSTEM TIMER
#include "scbregisters.hpp" // for SYSTEM TIMER
#include "tim2registers.hpp" // for TIMER 5
 
#include  "pin.h"
#include  "treemode.h"
#include  "chessmode.h"
#include  "basemode.h"
#include  "allmode.h"
#include  "garland.h"
#include  "buttonnextmode.h"
#include <iostream>

std::uint32_t freqTIM2 = 1'000'000U;
std::uint32_t SystemCoreClock = 16'000'000U;

extern "C" 
{
int __low_level_init(void)
{
  STK::CTRL::CLKSOURCE::CpuClock::Set();
  
  RCC::APB1ENR::TIM2EN::Enable::Set();
  return 1;

}
}

using tMsec = std::uint32_t;
extern "C"
{
void delay(tMsec period)
{
      const auto timerValue = static_cast<std::uint32_t>(period*(freqTIM2 / 1000U - 1U)); #(1)
      TIM2::PSC::Write(15); #(2)
      TIM2::CR1::URS::OverflowEvent::Set(); #(3)
      TIM2::ARR::Write(timerValue); #(4)
      TIM2::SR::UIF::Set(0); #(5)
      TIM2::CNT::Write(0); #(6)
      
      TIM2::CR1::CEN::Enable::Set(); #(7)
      while(TIM2::SR::UIF::Get() ==0) #(8)
      {
        
      }
      TIM2::CR1::CEN::Disable::Set(); #(9)
      TIM2::SR::UIF::Set(0); #(10)
     
      
      
}     
}

Pin<GPIOA, 5> pin1;
Pin<GPIOC, 9> pin2;
Pin<GPIOC, 8> pin3;
Pin<GPIOC, 5> pin4;

BaseMode<pin1, pin2, pin3, pin4> baseMode;
TreeMode<pin1, pin2, pin3, pin4> treeMode; 
ChessMode<pin1, pin2, pin3, pin4> chessMode;
AllMode<pin1, pin2, pin3, pin4> allMode;
Garland<treeMode, chessMode, allMode> garland;

ButtonNextMode<GPIOC, 13> button;

int main()
{  
  //Ïîäàòü òàêòèðîâàíèå íà ïîðò À
  RCC::AHB1ENR::GPIOAEN::Enable::Set() ;
  //Ïîäàòü òàêòèðîâàíèå íà ïîðò Ñ
  RCC::AHB1ENR::GPIOCEN::Enable::Set() ;
  //Ïîðòà À.5 íà âûâîä
  GPIOA::MODER::MODER5::Output::Set() ;
  //Ïîðòà C.5,C.8, C.9 íà âûâîä
  GPIOC::MODER::MODER5::Output::Set() ;
  GPIOC::MODER::MODER8::Output::Set() ;
  GPIOC::MODER::MODER9::Output::Set() ;
  //Ïîðò Ñ.13 íà ââîä
  GPIOC::MODER::MODER13::Input::Set() ;
  

  tMsec period = 500U;
  for(;;)
  {
     
     button.ButtonProcessing();
     if(button.IsPressedButton == true)
     {
        period = (period < tMsec(1000)) ? (period + tMsec(100U)) : tMsec(500U); #(11)
      
     } 
     allMode.Update();
     
     delay(period);
  }
  
  return 1;
}

----

Таймеры тактируются от шины APB1. Поэтому каждый отчсет таймера TIM2 и TIM5 по умолчанию происходит на частоте шины, т.е. если шина APB1 работает на частоте 1 Мгц, то один отсчет таймера произойдет через 1 мкс. Таким образом можно организовать измерение времени с разрешением в 1 мкс.

. Расчет значения которое будет помещено в таймер. Задаваемая частота равна 1 МГц, поэтому для отсчета 1 мс таймер должен достчитать до 1 000. Получится 1 000 000/1 000 и от этого нужно отнять 1, так как таймер считает от нуля. В конечном виде выглядит так timerValue = (period*(freqTIM2 / 1000U - 1U)), где period - это заданое число в функцию в миллисекундах, freqTIM2 - это частота таймера.

. Входную частоту таймера можно поделить, записав делитель частоты в решистр PSC. 16 разрядный регистр - делитель частоты для таймера. Коэффициент деления задается в 16-разрядном регистре, этот коэффициент можно задать в пределах от 1 до 65536.​

. Установить источник генерации прерываний по событию переполнение с помощью бита URS в регистре CR1. 

. Значение timerValue является интервалом времени которое можно, задать в регистр автоперезагрузки ARR. В этот регистр записывается число, до которого будет идти счет. При достижении этого значения, содержимое счетчика CNT обнуляется и формируются прерывание или запрос DMA (если они разрешены).​

. Скинуть флаг генерации прерывания UIF по событию в регистре SR​. Флаг прерывания по событию обновления. Бит устанавливается аппаратно, скидываться должен программно​.

. Установить начальное значение счетчика в 0 в регистре CNT

. Запустить счетчик с помощью бита CEN в регистре CR1

. Проверять пока не будет установлен флаг генерации прерывания по событию UIF в регистре SR

. Как только флаг установлен остановить счетчик, сбросить бит CEN в регистре CR1, 

. Сбросить флаг генерации прерывания UIF по событию в регистре SR

. При нажатии на кнопку заданое время 500 мс увеличивается на 100 мс в случае если период станет равным или больше 1 000 мс то он снова становится равным 500 мс.

== Заключение

В результате получили программу моргания всеми 4 светодиодами на плате с периодом в 0.5 секунды. По нажатию кнопки увеличивать период моргания на 0.1 секунды.

.Результат работы программы 
video::20231202_123530.mp4[]
