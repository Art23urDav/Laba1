:toc: macro 

include::Title4.adoc[lines=1..8]

[.text-center]
Отчет по лабораторной работе №4 +
на тему "Регистры"

include::Title4.adoc[lines=12..24]

== Оглавление

toc::[]

== Введение

Цель: Ознакомиться с регистрами и запустить программу для мигания светодиодов.


== Теория

Регистр - это ячейка памяти.

Скорость обращения к регистру равен частоте работы микроконтроллера

Регистры существуют двух видов: регистры общего назначения и специальные регистры.

Регистры общего назначения расположены внутри ядра микроконтроллера. Это сверхбыстрая память внутри процессора, предназначенная для хранения адресов и промежуточных результатов вычислений (регистр общего назначения/регистр данных) или данных, необходимых для работы самого процессора.

Регистры специального назначения расположены в ОЗУ микроконтроллера и используются для управления процессором и периферийными устройствами.

Регистры в микроконтроллерах представляет собой ресурс памяти, который имеет длину в 32 бита, где каждый бит можно представить в виде выключателя с помощью которого осуществляется управление тем или иным параметром микроконтроллера.

=== Регистры общего назначения

У регистров общего назначения нет адреса есть только имя к которому можно обращаться

Процессор располагает 16-ю 32-разрядными регистрами общего назначения (РОН, GPR), из которых три на деле имеют специальные функции:

. Оперативные регистры. Регистры R0-R3, R12 являются оперативными(sratch) регистрами. Любая функция может использовать эти регистры по своему усмотрению и уничтожать содержимое этих регистров. Если функции нужны значения этих регистров после вызова другой функции, она должна сохранить их на стеке, а после вызова восстановить.

. Вспомогательные регистры. Регистры от R4-R11 являются вспомогательными. Любая функция должна сохранить их на входе, а при выходе восстановить их значение.

. Специальные регистры:
.. Регистр указателя на стек R13/SP, должен всегда указывать на последний элемент стека или ниже него.

.. Регистр R15/PC есть программный счетчик.

.. Регистр R14/LR, содержит адрес возврата функции. Адрес места в который должны возратиться после выполнения функции.

=== Регистры специального назначения

В отличии от регистров общего назначения у регистра специального назначения есть адрес, так как они находятся в ОЗУ.

Рассмотрим схематичное изображение регистра специального назначения.

.Схематичное изображение регистра
image::picture\Схема регистра.png[]

Адрес регистра обозначается 32-битным шестнадцатеричным числом.

Поле - набор ячеек регистра, отвечающих за работу одной из функции микроконтроллера. 

У каждого поля и значений поля есть режимы доступа некоторые поля можно только читать, только писать или писать и читать одновременно.

Длина - количество ячеек в одном регистре. Мы будем работать с 32-битными регистрами.

Значение поля - есть пространство всех возможных величин, которые может принимать поле. Значение поля зависит от длины поля. Т.е. если поле имеет длину 2, то существует 4 возможные значения поля (0,1,2,3). 

=== Доступ регистра специального назначения

Для доступа к регистрам специального назначения можно использовать reinterpret_cast, который преобразует типы, несовместимыми друг с другом, преабразуем адрес в указатель uint32_t.

.main.cpp
[source, cpp]
---
int main()
{  
std::uint32_t* ptr =reinterpret_cast<std::uint32_t*>(0x40020014) # (1)
*ptr = 1U << 5U; #(2)
GPIOC::ODR::ODR5::High::Set(); #(3)


}
---

. Объявляем переменную ptr и присваиваем ей значение адреса преобразованого в указатель uint32_t.

. Разыминовываем указатель и присваиваем ей значение 1 со сдвигом к нужному полю.

. Те же самые действия (в порт С5 записывается 1), но с использованием специального класса на С++

== Практическая часть

Произведем доступ к регистрам двумя способами с помощью специального класса на С++ и reinterpret_cast.
Код программы для мигания светодиодов А и С:

.main.cpp
[source, cpp]
---
#include "rccregisters.hpp" // for RCC
#include "gpioaregisters.hpp" // for GPIOA
#include "gpiocregisters.hpp" // for GPIOС

std::uint32_t SystemCoreClock = 16'000'000U;

extern "C" 
{
int __low_level_init(void)
{
  
}
}

void delay(int cycles)
{
  for(int i = 0; i < cycles; ++i)    
  {   
    asm volatile("");
  }    
}

int main()
{  
  //Подать тактирование на порт А
  RCC::AHB1ENR::GPIOAEN::Enable::Set() ;
  //Подать тактирование на порт С
  RCC::AHB1ENR::GPIOCEN::Enable::Set() ;
  //Порта А.5 на вывод
  GPIOA::MODER::MODER5::Output::Set() ;
  //Порта C.5,C.8, C.9 на вывод
  GPIOC::MODER::MODER5::Output::Set() ;
  GPIOC::MODER::MODER8::Output::Set() ;
  GPIOC::MODER::MODER9::Output::Set() ;
  
  std::uint32_t* ptr =reinterpret_cast<std::uint32_t*>(0x40020014); //0x40020014 ==  регистр ODR светодиода А 
  for(;;)
  {
   
     GPIOC::ODR::ODR8::High::Set();
     *ptr ^= 1U<<5U; // Исключающее или позволяет выставить бит в 1 при этом не изменяя другие биты
     delay(1000000); 
     GPIOC::ODR::ODR8::Low::Set();
     *ptr ^= 1U<<5U; // Повторяем эту операцию чтобы светодиоды А и С мигали в один момент
     delay(1000000);
   
  }
  
  return 1;
}

---

Результат загрузки программы в микроконтроллер:

.Мигание двух светодиодов
video::Video\Мигание двух светодиодов.mp4[]

Качество камеры не передает мигание светодиодов А и С, поэтому кажется что мигают три светодиода.

== Вывод 

В ходе данной лабораторной работы изучены виды регистров, способ доступа к ним, написана программа для мигания светодиодов A и С, с помощью регистров был произведен прямой доступ к памяти.