:toc: macro 

include::Title6.adoc[lines=1..8]

[.text-center]
Отчет по лабораторной работе №6 +
на тему "Порты общего назначения"

include::Title6.adoc[lines=12..24]

== Оглавление

toc::[]

== Введение

Основные характеристики:

* 5 портов общего назначения​;
* 16 линий ввода вывода​;
* Режимы входа: цифровой (с подтяжкой к 1 и к 0) и аналоговый​;
* Возможность работы в альтернативном режиме​.

Задание: рассмотреть виды портов и зажечь светодиоды в режиме елочки.

== Режимы работы портов
Различные режимы работы портов
* Плавющий цифровой вход (Input floating);
* Цифровой вход с подтяжкой к 1 (Input pull-up);
* Цифровой вход с подтяжкой к 0 (Input-pull-down);​
* Аналоговый (Analog);​
* Цифровой выход с открытым коллектором с подтяжкой к 1 или к 0 (Output open-drain with pull-up or pull-down capability);
* Цифровой двухтактный выход с подтяжкой к 1 или к 0 (Output push-pull with pull-up or pull-down capability)​;
* Альтернативная функция с открытым коллектором с подтяжкой к 1 или к 0 (​Alternate function push-pull with pull-up or pull-down capability);
* Альтернативная функция двухтактный выход с подтяжкой к 1 или к 0 ()​Alternate function open-drain with pull-up or pull-down capability).

В цифровом режиме порт имеет два состояния 1(true) и 0(false) или говоря на языке электроники Hihg и Low. Эти сигналы соотвествуют уровню питания микроконтроллера, High соотвествует 3-3.3В, a Low - 0 В.

=== Работав в цифровом режиме 

С помощью портов можно управлять работой других устройств.

Например, можно управлять режимом работы светодиода. На рисунке <<Работа в цифровой режиме>> показан источник питания, резистор, который ограничивает ток и определяет яркость светодиода. Светодиод подключен к питанию, а микроконтроллер подключают вторую часть к земеле в итоге ток течет от + к - и светодиод горит.

.Работа в цифровой режиме
image::picture\Работа в цифровом режиме.png[]

=== Цифровой выход

Когда порт настроен как цифровой выход им можно управлять. Например, если вы задали состояние порта High, то порт подключается к питнию, в итоге на ножке порта появляется высокий уровень напряжения. В случае, если вы задали Low, на ножке порта появляется низкий уровень напряжения или 0.

.Работа в цифровой режиме
image::picture\Цифровой выход.png[]

=== Цифровой вход 

Когда порт настроен как цифровой вход, контакт никуда не подключен ни к земле ни к питанию, поэтому ток никуда не течет. Любое напряжение на такой ножке будет интерпретирована как 1 или 0, в зависимости от уровня напряжения высокого или низкого. В таком случае это называется "подвешенная" или плавающая ножка, тогда наводка или шум на этой ножке может быть интерпретирован как 1 или 0 в зависимости от уровня шума. Таким образом такая плавающая "ножка" не очень хороша для использования, так как могут генерироваться ложные переходы.

.Работа в цифровой режиме
image::picture\Цифровой вход.png[]

=== Цифровой вход с подтяжкой

Для того избавления от плавющего сигнала на ножке обычно её подтягивают к 0 или 1. Обычно эта опция уже есть внутри микроконтроллера или может быть настроена внешне.

Цифровой вход с подтяжкой к 1 означает что на порту всегда будет напряжение 3 В, тогда как цифровой вход с подтяжкой к 0 означает что порт подключен к земле. 

.Цифровой вход с подтяжкой
image::picture\Цифровой вход с подтяжкой.png[]

== Регистры портов общего назначения​

* GPIOx_MODER (port mode register). Задает режимы работы индивидуально каждого из вывода порта. Каждый из выводов GPIO может быть настроен как вход, выход, работать в аналоговом режиме, или подключен к одной из альтернативных функций. ​
Регистр MODER нужен для выбора режимов порта. 
** Выставив в данном регистре 00 порт будет работать на вход, если нужно что-то подать на порт, например кнопка. 
** Выставив в данном регистре 01 порт будет работать на выход, если черрез данный порт нужно что-то выдать, например светодиод.
** Выставив в данном регистре 10 порт будет работать как альтернативная функция, требуется если порт используется каким-нибудь модулем, например SPI, UART и т.д.
** Выставив в данном регистре 11 порт будет работать в аналоговом режиме, используется когда мы хотим через вход измерять аналоговые сигналы, например АЦП.

* GPIOx_OSPEEDR (port output speed register). Задает скорость работы порта: 400кГц, 2МГц, 10МГц и 40Мгц.​ 

* GPIOx_PUPDR (port pull-up/pull-down register). Задает подключение подтягивающих резисторов. Без подтягивающего резистора, с подтяжкой к «+» питания, ​с подтяжкой к «gnd» земле. ​

* GPIOx_IDR (input data register). регистр входных данных, из которого считывается состояние входов порта.​

* GPIOx_ODR (output data register). регистр выходных данных. Запись числа в младшие 16 бит, приводит к появлению соответствующих уровней на выводах порта.​

* GPIOx_OTYPER (port output type register). В режиме выхода или альтернативной функции, соответствующий бит регистра устанавливает тип выхода. ​Push-Pull (двухтактный) или Open Drain (выход с открытым коллектором).​

* Не рекомендуется использовать регистр GPIOx_ODR для изменения портов, для этого есть регистр GPIOx_BSRR (port bit set/reset register). Этот регистр позволяет «атомарно» установить или сбросить бит на выходных линиях порта. Атомарные операции с регистром GPIOx_BSRR выполняются за один цикл записи. При этом операции установки/сброса имеют однократный эффект. Предыдущее состояние модифицируемого бита регистра GPIOx_BSRR совершенно неважно, можно сколько угодно «пихать» туда единицы и каждый раз регистр GPIOx_ODR будет реагировать соответствующим образом. 

* GPIOxLCKR (port configuration lock register). Позволяет «заморозить», то есть защитить от изменения текущую настройку конфигурации. Можно запретить модификацию следующих регистров управления: GPIOx_MODER, GPIOx_OTYPER, GPIOx_OSPEEDR, GPIOx_PUPDR, GPIOx_AFRL, GPIOx_AFRH.​

В данной работе будут использованы только регистры GPIOx_MODER

=== Работа с портами в режиме общего назначения​

Определим какой порт будет использовать​ся. В работе будут использоваться порты А.5, C.5, C.8, C.9.

Все порты тактируется от шины AHB1. Подключим нужный порт к источнику частоты. Подадим тактирование на порт А и С:

main.cpp
[source, cpp]
---
  RCC::AHB1ENR::GPIOAEN::Enable::Set();
  RCC::AHB1ENR::GPIOCEN::Enable::Set();
--- 

Настроем порты А.5, C.5, C.8, C.9 на выход.

main.cpp
[source, cpp]
---
  GPIOA::MODER::MODER5::Output::Set(); // А.5 на выход
  GPIOC::MODER::MODER5::Output::Set(); // C.5 на выход
  GPIOC::MODER::MODER8::Output::Set(); // C.8 на выход
  GPIOC::MODER::MODER9::Output::Set(); // C.9 на выход
--- 


== Практическая часть 

Задание: зажечь светодиоды в режиме елочки, т.е. зажечь светодиод 1, светодиод 2, светодиод 3, светодиод 4 и потушить в том же порядке.

=== Код программы

Создадим класс Pin в отдельном файле и в ней функцию Toggle, которая позволит менять требуемый бит, с помощью передавемых в класс значений порта и номера порта.

main.cpp
[source, cpp]
---
#ifndef PIN
#define PIN

#include "gpioaregisters.hpp" // for GPIOA

template<typename Port, int pinNumber>
class Pin
{
public:
  void Toggle()
  {
    Port::ODR::Toggle(1<<pinNumber);
  }
};
#endif
---

В результате получим код:

main.cpp
[source, cpp]
---
#include "rccregisters.hpp" // for RCC
#include "gpioaregisters.hpp" // for GPIOA
#include "gpiocregisters.hpp" // for GPIOС
#include  "pin.h"

std::uint32_t SystemCoreClock = 16'000'000U;

extern "C" 
{
int __low_level_init(void)
{
  
}
}

void delay(int cycles)
{
  for(int i = 0; i < cycles; ++i)    
  {   
    asm volatile("");
  }    
}

template<auto& pin1, auto& pin2, auto& pin3, auto& pin4>
class Elochka
{
public:
  void ToggleElochka()
  {
    pin1.Toggle();
    delay(1000000);
    pin2.Toggle();
    delay(1000000);
    pin3.Toggle();
    delay(1000000);
    pin4.Toggle();
    delay(1000000);
  }
};

Pin<GPIOA, 5> pin1;
Pin<GPIOC, 9> pin2;
Pin<GPIOC, 8> pin3;
Pin<GPIOC, 5> pin4;
Elochka<pin1, pin2, pin3, pin4> elochka;


int main()
{  
  //Подать тактирование на порт А
  RCC::AHB1ENR::GPIOAEN::Enable::Set() ;
  //Подать тактирование на порт С
  RCC::AHB1ENR::GPIOCEN::Enable::Set() ;
  //Порта А.5 на вывод
  GPIOA::MODER::MODER5::Output::Set() ;
  //Порта C.5,C.8, C.9 на вывод
  GPIOC::MODER::MODER5::Output::Set() ;
  GPIOC::MODER::MODER8::Output::Set() ;
  GPIOC::MODER::MODER9::Output::Set() ;
  
  
  
  for(;;)
  {
        
     elochka.ToggleElochka();
     
     delay(1000000);
  }
  
  return 1;
}

---


=== Результат

.Работа светодиодов в режиме елочка
video::Video\Работа светодиодов в режиме елочка.mp4[]

Вывод: разобрали порты общего назначения, регистры для работы с ними, виды портов и написали программу для мигания светодиодов в режиме елочки.