:toc: macro 

include::Title.adoc[lines=1..8]

[.text-center]
Отчет по лабороторной работе №1 +
на тему "Запуск программного обеспечения на микроконтроллере"

include::Title.adoc[lines=12..24]

[.text-center]
Отчет по лабороторной работе №1 +
на тему "Запуск программного обеспечения на микроконтроллере"

== Оглавление

toc::[]

== Задание 1

Задачи: 

. Создать проект C++ c main.cpp;
. Подключить к проекту файл cstartup.cpp;
. Создать папки AbstractHardware/Registers/FiledValues, Common, Application, FreeRtos;
. Создать структуру проекта в соотвествии со структурой папок;
. Настроить STACK, HEAP;
. Скопировать содержимое папки Registers и Common с проекта преподавателя в свою папку;
. Написать программу в main.cpp.

Создав проект на С++ с шаблоном main.cpp. Подключаем к проекту файл cstartup.cpp. В этом файле описывается таблица вектров прерываний и начальная инициализация. 

Далее создадим папки AbstractHardware/Registers/Filed Values, Common, Application, FreeRtos. 
В папке AbstractHardware/Registers будут находится файлы с описанием полей регистров.
В папке AbsstractHardware будут содержаться файлы для работы с регистрами, аппаратурой и периферией.
В папке Application в дальнейшем будут содержаться файлы классов для работы с логикой программы.
Папка FreeRtos пригодиться при работе с ОСРВ.

.Содержимое папки проекта
image::picture\Содержимое папки проекта.jpg[]

Размер стека (Stack) установили в 0x1000 и кучи (Heap) можно установить в 0.

.Установленные стека и кучи
image::picture\Установка стека и кучи.jpg[]

Скопировали содержимое папки Registers и Common с проекта преподавателя в свою папку.

Пишем программу в main.cpp.

.main.cpp
[source, cpp]
----
#include "rccregisters.hpp" // for RCC
#include "gpioaregisters.hpp" // for GPIOA
#include "gpiocregisters.hpp" // for GPIOÑ

std::uint32_t SystemCoreClock = 16'000'000U;

extern "C" 
{
int __low_level_init(void)
{
  
}
}

void delay(int cycles)
{
  for(int i = 0; i < cycles; ++i)    
  {   
    asm volatile("");
  }    
}

int main()
{  
  //Подать тактирование на порт A
  RCC::AHB1ENR::GPIOAEN::Enable::Set() ;
  //Подать тактирование на порт C
  RCC::AHB1ENR::GPIOCEN::Enable::Set() ;
  //порта а.5 на вывод
  GPIOA::MODER::MODER5::Output::Set() ;
  //порта C.5,C.8, C.9 на вывод
  GPIOC::MODER::MODER5::Output::Set() ;
  GPIOC::MODER::MODER8::Output::Set() ;
  GPIOC::MODER::MODER9::Output::Set() ;
  
  for(;;)
  {
   
     GPIOA::ODR::ODR5::High::Set();
     GPIOC::ODR::ODR5::High::Set();
     delay(1000000); 
     GPIOA::ODR::ODR5::Low::Set();
     GPIOC::ODR::ODR5::Low::Set();
     delay(1000000); 
  }
  
  return 1;
}

----

== Задание 2

Задачи: 

. Откомпилировать и отлинковать программу;
. Загрузить программу в симуляторе;
. Сделать пошаговую отладку;
. Настроить Debugger на отладку через StLink;
. Подключить плату к компьютеру;
. Загрузить программу в плату;
. Выполнить пошаговую отладку;
. Описать полученный результат.



Откомпилируем и отлинкуем программу.

.Компиляция и линковка
image::picture\Компиляция и компановка.jpg[]

Далее проведем пошаговую отладку. Установим точку останову на строчку 43 кода программы main.cpp.

.Пошаговая отладка
image::picture\Пошаговая отладка.jpg[]

Настраиваем Debugger на отладку через StLink.

.Настройка Debugger на отладку через StLink
image::picture\Настройка дебагера.jpg[]

Далее подключаем плату к компьютеру и загружаем программу в плату. После загрузки программы на плате начинают мигать 2 светодиода: LED1 и LED4.

Проведем пошаговую отладку установив точку остановы на строчку 40. Благодаря коду на этой строчке светодиод LED4 светится.

.Пошаговая отладка строчки 40
image::picture\Пошаговая отладка 40 строчки.jpg[]

В результате загрузки программы на плату получили 2 мигающих светодиода.

== Задание 3

Задачи: 

. Создать map файл;
. Описать что написано в map файле;
. Поставить размер кучи HEAP в 0. Объяснить почему так можно сделать. И почему STACK нельзя.

Создаем map файл, в нем хранятся названия переменных и функций, их адреса, размеры, а также в каких сегментах они располагаются

Куча уже установлена в 0. Куча используется только при динамически выделяемой памяти. Динамическое выделение памяти не рекомендуется для использования в надежном ПО. Лучше делать все объекты статическими.

В стеке сохраняются регистры в те моменты когда вызывают подпрограмму, или проваливаются в прерывание, для того, чтобы когда вернуться обратно в программу восстановить весь контекст и все переменные. Если в функции передается слишком много переменных и под все не хватит регистров, то компилятор расположит их также на стеке. Локальные переменные функции также создаются на стеке. Поэтому размер стека нельзя поставить нулевым

== Заключение

Таким образом в ходе данной работы был создан проект, написана программа, позволяющая мигать двумя светодиодами, изучен процесс компилирования и отлинковки программы, была произведена пошаговая отладка, загрузка программы в плату и в результате на плате начали мигать два светодиода, изучено содержимое map файла, а также что такое куча и стек, и какими размерами они должны обладать.