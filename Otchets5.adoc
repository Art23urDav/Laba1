:toc: macro 

include::Title5.adoc[lines=1..8]

[.text-center]
Отчет по лабораторной работе №5 +
на тему "Соглашение об вызовах"

include::Title5.adoc[lines=12..24]

== Оглавление

toc::[]

== Введение

Задание: Рассмотреть что такое соглашение об вызовах и что в нее входит.

Соглашение об вызовах включает в себя: 

* Объявление функции;
* Компоновка С и С++ кода; 
* Последовательность использования оперативных регистров и вспомогательные регистров; 
* Вход в функцию;
* Выход из функции; 
* Обработка адреса возврата.

== Объявление функции

Функция должна быть объявлена в таком порядке, чтобы компилятор мог узнать как её вызвать.
Пример объявления функции:

main.cpp
[source, cpp]
int MyFunction(int first, char * second);

. Тип возвращаемого значения (int);
. Название функции (MyFunction);
. В скобках параметры, которые передаются в функцию (int first, char * second);
.. Параметр типа int с названием first (int first);
.. Параметр указатель на символ (char * second).

== Компоновка С и С++ кода

При компановке кода в Си название функции превращается в метку, поэтому из ассемблера можно обратится по этой метке. В С++ не получиться напрямую из ассеблера обратиться к функции, из-за функции декорирования, которая в метке записывает название и тип. 

В C+ , функция может компоноваться либо как С +, либо как С функция. Пример объявления функции с Си компоновкой:
main.cpp
[source, cpp]
---
extern "C" {
  int F(int);
}
--- 

Если вы хотите вызвать функции ассемблера из С++, то лучше объявить эту функцию, как имеющую тип компоновки Си.

== Вход функции

Параметры передающие в функцию могут использовать два метода:

* Через регистры
* Через стек

Так как регистры это сверхбыстрая память, которая работает на частоте процессора, компилятор в первую очередь использует регистры для передачи параметров. Но число регистров ограничено, поэтому если регистров не хватает, то используется стек. Для передачи параметров используются оперативные регистры R0:R3.

== Выход из функции

Функция может вернуть значение. Для возврата значения используются регистры R0:R1. Если значение больше 64 бит, то в регистр R0 записывается адрес где лежат данные.

Вызывающая функция обязана очистить стек, после того, как вызываемая функция вернула значение.

== Операторы С++

Задание: Написать виды операторов, более подробно разобрать оператор унарный плюс, инкримент (пост и предфиксный), операторы sizeof и запятая.

Операторы бывают: 

* Арифметические операторы;
* Операторы сравнения;
* Логические операторы;
* Побитовые операторы;
* Составное присваивание;
* Операторы работы с указателями и членами класса;
* Функторы, тернарные операции, sizeof(), запятая, приведение типа, new.

.Арифметические операторы
[cols="4,4,4"]
|=====================
|Операция | Оператор | Комментарий
|Присваивание       | =     | a = b
|Сложение           | +     | a + b
|Вычитание          | -     | a - b
|Унарный плюс       | +     | +a
|Унарный минус      | -     | -a
|Умножение          | *     | a * b
|Деление            | /     | a / b
|Остаток от деления | %     | a % b
|Инкремет  (пост и предфиксный)| ++      | &#43;&#43;a  и  a&#43;&#43;
|Декремент (пост и предфиксный)| - -     | --a и a--
|=====================

.Логические операторы
[cols="4,4,4,7"]
|=====================
|Операция | Оператор | Комментарий | Пример
|Логическое отрицание, НЕ   | !     | !a    |   !true => false
|Логическое умножение, И    | &&    | a && b| true && false => false
|Логическое сложение, ИЛИ   | &#124;&#124;  |   a &#124; &#124;  b  | true &#124; &#124;  false => true
|=====================

.Побитовые операторы
[cols="4,4,4,7"]
|=====================
|Операция | Оператор  | Комментарий | Пример
|Побитовая инверсия   | ~     | ~a  | unsigned char a = 0; ~a => 0xFF
|Побитовое И          | &     | a & b | unsigned char a = 1, b = 3; a & b => 1
|Побитовое ИЛИ        | &#124;   | a &#124; b | unsigned char a = 1, b = 3; a &#124; b => 3
|Побитовое исключающее ИЛИ  | ^   | a ^ b | unsigned char a = 1, b = 3; a ^ b => 2
|Побитовый сдвиг влево  | <<   | a << b | unsigned char a = 1, b = 3; a << b => 8
|Побитовый сдвиг вправо | >>   | a >> b | unsigned char a = 8, b = 3; a >> b => 1
|=====================

=== Арифмитический оператор унарный плюс

Над целочисленными операндами выполняется восходящее приведение целого типа. Результирующим типом является тип, до которого повышается уровень операнда. К примеру 

main.cpp
[source, cpp]
---
char a = 0; #(1)
+а; #(2)

---

. Инициализируем переменную а типа char;
. Выражение +a приводит к типу int, при этом значение не будет изменено.

=== Инкримент (пост и предфиксный)

Постинкримент прибавляет единицу после вычесления выражения. Прединкримент до вычесления выражения.

Пример: 

main.cpp
[source, cpp]
---

int a = 0; 
int b = ++a; #(1)
int c = a++; #(2)

---

. Сначала к переменной а прибавится единица, только потом это значение присвоется к переменной b, в результате b равна 1, а равна 1;
. Сначала к переменной с присвоется значение а, только потом к переменной прибавится единица, в результате с равна 0, а равна 1.

=== Оператор sizeof

Оператор sizeof предоставляет объем хранения (в байтах), необходимого для хранения объекта типа переменной.

Пример:

main.cpp
[source, cpp]
---

int arr[]= {1, 2, 3, 4, 5};
int* arr1= arr;
std::cout << sizeof(arr) << std::endl; #(1)
std::cout << sizeof(arr1) << std::endl; #(2)

---

. Размер массива будет 20 байт, так как переменная в массиве имеет тип int, который занимает по 4 байта, то 4*5=20;
. В этой операции будет выведен размер самого указателя типа int, то есть 4.

=== Оператор запятая

Два выражения, разделенные запятой, вычисляются в направлении слева направо. Левый операнд вычисляется всегда и перед вычислением правого операнда учитываются все побочные эффекты.

Пример:
main.cpp
[source, cpp]
---
int i = 10, b = 20, c = 30;
i = b, i = c;
---

В результате получим i равную 30.

== Ядро CortexM4

Задание: расмотреть Ядро CortexM4 и его характеристики.

.Ядро CortexM4
image::picture\CortexM4.png[]

* Ядро Cortex построено по гарвардской архитектуре с разделением шины данных и кода. ​

* Ядро Cortex-М4 поддерживает 8/16/32-разрядные операции умножения, которые выполняются за 1 цикл (деление со знаком (SDIV) или без (UDIV) занимает от 2 до 12 тактов в зависимости от размера операндов​

* Ядро Cortex-М4 поддерживает 8/16/32-разрядные операции умножения со сложением​

=== Характеристики ядра CortexM4

[cols="4,4"]
|===
| Параметр​ | ARM Cortex-M4​
| Архитектура​ | ARMv7 (Гарвардская)​
| Набор инструкций​ | Thumb/Thumb-2, DSP, SIMD, FP​
| Конвейер​ |   3 уровня + предсказание ветвлений​
| Прерывания​ | NMI (немаскируемые) + от 1 до 240 физических источников прерываний​
| Длительность входа в обработчик прерывания​ | 12 циклов​
| Длительность переключения между обработчиками прерываний​ | 6 циклов​
| Режимы пониженного энергопотребления​ | Встроены​
| Защита памяти​ | Блок защиты памяти с 8 областями​
| Производительность по тесту Dhrystone​ | 1,25 DMIPS/МГц​
| Энергопотребление ядра​ | 0,19 мВт/МГц​
| Аппаратный модуль работы с плавающей точкой ​| есть​
|===

== Блок диаграмма микроконтроллера

Задание: расмотреть схему микроконтроллера.

Блок схема микроконтроллера:

.Блок схема микроконтроллера
image::picture\Блок схема микроконтроллера.png[]

Из дополнительных особенностей, которые понадобятся для лабораторных работ следует выделить:

. Настраиваемые источники тактовой частоты;
. Настраиваемые на различные функции порты;
. Внутренний температурный сенсор;
. Таймеры с настраиваемым модулем ШИМ;
. DMA для работы с модулями (SPI, UART, ADC… );
. 12 разрядный ADC последовательного приближения;
. Часы реального времени;
. Системный таймер и спец. прерывания для облегчения и ускорения работы ОСРВ;

== Система тактирования

Задание: рассмотреть что такое тактирование.

Такт процессора или такт ядра процессора - промежуток между двумя импульсами тактового генератора, который синхронизирует выполнение всех операций процессора.

Тактовая частота - частота синхронизирующих импульсов синхронной электронной схемы, то есть количество синхронизирующих тактов, поступающих извне на вход схемы за одну секунду. Тактовая частота - это количество тактовых сигналов за одну секунду.

Для формирования системной тактовой частоты SYSCLK могут использоваться 4 основных источника:​

* HSI (high-speed internal) — внутренний высокочастотный RC-генератор, 16 МГц.​
* HSE (high-speed external) — внешний высокочастотный генератор, 4-26 МГц в нашем микроконтроллере 8 МГц.​
* PLL — система ФАПЧ. Точнее сказать, это вовсе и не генератор, а набор из умножителей и делителей, исходный сигнал он получает от HSI или HSE, а на выходе у него уже другая частота.

Также имеются 2 вторичных источника тактового сигнала:​

* LSI (low-speed internal) — низкочастотный внутренний RC-генератор на 37 кГц​
* LSE (low-speed external) — низкочастотный внешний источник на 32,768 кГц​

== Практическая часть 

Задание: Сформировать тактовую частоту 34 МГц с помощью системы ФАПЧ.

Порядок использования системы ФАПЧ укзан в справочном руководстве к STM32F411.

Следуя руководству был написан следующий код:

main.cpp
[source, cpp]
---
#include "rccregisters.hpp" // for RCC
#include "gpioaregisters.hpp" // for GPIOA
#include "gpiocregisters.hpp" // for GPIOС

std::uint32_t SystemCoreClock = 16'000'000U;


extern "C" 
{
int __low_level_init(void)
{
  // Switch on HSI
  RCC::CR::HSION::On::Set();
  while (RCC::CR::HSIRDY::NotReady::IsSet())
  {
  }
  
  RCC::CR::PLLON::On::Set();
  *reinterpret_cast<std::uint32_t*>(0x40023804) &= 0;
  RCC::PLLCFGR::PLLSRC::HsiSource::Set();
  RCC::PLLCFGR::PLLP0::Pllp2::Set();
  *reinterpret_cast<std::uint32_t*>(0x40023804) |= (1U << 4U);
  *reinterpret_cast<std::uint32_t*>(0x40023804) |= (1U << 12U);
  while (RCC::CR::PLLRDY::Unclocked::IsSet())
  {
  }
  RCC::CFGR::SW::Pll::Set();
  while (!RCC::CFGR::SWS::Pll::IsSet())
  {
  }
  RCC::APB2ENR::SYSCFGEN::Enable::Set();
  return 1;
  
}
}


void delay(int cycles)
{
  for(int i = 0; i < cycles; ++i)    
  {   
    asm volatile("");
  }    
}


int main()
{  
  //Подать тактирование на порт А
  RCC::AHB1ENR::GPIOAEN::Enable::Set() ;
  //Подать тактирование на порт С
  RCC::AHB1ENR::GPIOCEN::Enable::Set() ;
  //Порта А.5 на вывод
  GPIOA::MODER::MODER5::Output::Set() ;
  //Порта C.5,C.8, C.9 на вывод
  GPIOC::MODER::MODER5::Output::Set() ;
  GPIOC::MODER::MODER8::Output::Set() ;
  GPIOC::MODER::MODER9::Output::Set() ;
  
  
  for(;;)
  {
     GPIOA::ODR::ODR5::High::Set(); 
     GPIOC::ODR::ODR9::High::Set();
     delay(1000000);
     GPIOA::ODR::ODR5::Low::Set();
     GPIOC::ODR::ODR9::Low::Set();
     delay(1000000);
     
     
  }
  
  return 1;
}

---

== Заключение

.Работа микроконтроллера на частоте тактирования 34 МГц
video::Мигание светодиодов при тактировании 34 МГц.mp4[]

В ходе данной работы был описано соглашение об вызовах и что в нее входят, какие существуют операторы С++, расмотрено ядро CortexM4, его характеристики и блок схема микроконтроллера, также изучено что такое тактирование.